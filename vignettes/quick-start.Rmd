---
title: "`lacunr` Quick-start guide"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{`lacunr` Quick-start guide}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "png", dev.args = list(type = "cairo-png"),
  fig.retina=2,
  pngquant = "--speed=1 --quality=50"
)
```

The standard workflow for `lacunr` is fairly simple:

1. Convert point cloud data to voxels using `voxelize()`
2. Arrange the voxels into a 3-dimensional array using `bounding_box()`
3. Calculate a lacunarity curve using `lacunarity()`

```{r}
library(lacunr)
# create a data.frame of simulated point cloud data
set.seed(5678)
pc <- data.frame(X = rnorm(1000, 10), Y = rnorm(1000, 50), Z = rnorm(1000, 25))
# convert to voxels of size 0.5
vox <- voxelize(pc, edge_length = c(0.5, 0.5, 0.5))
# generate 3D array
box <- bounding_box(vox)
# calculate lacunarity curve
lac_curve <- lacunarity(box)
```

Lacunarity and H(r) curves can be plotted using `lac_plot()`, `lacnorm_plot()`, or `hr_plot()`:

```{r fig.width=6, out.width="97%", fig.asp=1/2}
# plot lacunarity curve
plot <- lac_plot(lac_curve)
print(plot)
```

3D arrays generated by `bounding_box()` can have their dimensions selectively increased using `pad_array()`:

```{r}
# add two layers of empty space to the Z axis of the array
box_pad1 <- pad_array(box, z = 2)
# add two layers of occupied space to the Y axis of the array
box_pad2 <- pad_array(box, y = 2, fill = 1)
```

For more extensive explanation on these functions and their use, please see the package documentation (available by typing `?lacunr` into your console), or the other vignettes via `browseVignettes("lacunr")`.